package osvscanner

import (
	"fmt"
	"sort"

	"github.com/google/osv-scanner/internal/sourceanalysis"
	"github.com/google/osv-scanner/pkg/grouper"
	"github.com/google/osv-scanner/pkg/models"
	"github.com/google/osv-scanner/pkg/osv"
	"github.com/google/osv-scanner/pkg/reporter"
)

// groupResponseBySource converts raw OSV API response into structured vulnerability information
// grouped by source location.
func groupResponseBySource(r reporter.Reporter, packages []Package, resp *osv.HydratedBatchedResponse, allPackages bool, callAnalysis bool) models.VulnerabilityResults {
	output := models.VulnerabilityResults{
		Results: []models.PackageSource{},
	}
	groupedBySource := map[models.SourceInfo][]models.PackageVulns{}

	for i, rawPkg := range packages {
		response := resp.Results[i]
		if len(response.Vulns) == 0 && !allPackages {
			continue
		}
		var pkg models.PackageVulns
		if rawPkg.Commit != "" {
			pkg.Package.Version = rawPkg.Commit
			pkg.Package.Ecosystem = "GIT"
		} else if rawPkg.PURL != "" {
			var err error
			pkg.Package, err = models.PURLToPackage(rawPkg.PURL)
			if err != nil {
				r.PrintError(fmt.Sprintf("Failed to parse purl: %s, with error: %s",
					rawPkg.PURL, err))

				continue
			}
		} else {
			pkg = models.PackageVulns{
				Package: models.PackageInfo{
					Name:      rawPkg.Name,
					Version:   rawPkg.Version,
					Ecosystem: string(rawPkg.Ecosystem),
				},
			}
		}

		if len(response.Vulns) > 0 {
			pkg.Vulnerabilities = response.Vulns
			groups := grouper.Group(grouper.ConvertVulnerabilityToIDAliases(pkg.Vulnerabilities))
			pkg.Groups = groups
		}
		groupedBySource[rawPkg.Source] = append(groupedBySource[rawPkg.Source], pkg)
	}

	for source, packages := range groupedBySource {
		if callAnalysis {
			sourceanalysis.Run(r, source, packages)
		}
		output.Results = append(output.Results, models.PackageSource{
			Source:   source,
			Packages: packages,
		})
	}

	sort.Slice(output.Results, func(i, j int) bool {
		if output.Results[i].Source.Path == output.Results[j].Source.Path {
			return output.Results[i].Source.Type < output.Results[j].Source.Type
		}

		return output.Results[i].Source.Path < output.Results[j].Source.Path
	})

	return output
}
