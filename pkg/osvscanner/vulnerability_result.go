package osvscanner

import (
	"fmt"
	"sort"

	"github.com/google/osv-scanner/internal/sourceanalysis"
	"github.com/google/osv-scanner/pkg/grouper"
	"github.com/google/osv-scanner/pkg/models"
	"github.com/google/osv-scanner/pkg/osv"
	"github.com/google/osv-scanner/pkg/reporter"
)

// assembleResult takes the responses from the OSV API and the deps.dev API
// and converts this into a VulnerabilityResults. As part is this, it groups
// vulnerability information by source location.
func assembleResult(
	r reporter.Reporter,
	packages []Package,
	vulnsResp *osv.HydratedBatchedResponse,
	licensesResp [][]models.License,
	allPackages bool,
	callAnalysis bool,
	licenses bool,
	licensesAllowlist []string,
) models.VulnerabilityResults {
	output := models.VulnerabilityResults{
		Results: []models.PackageSource{},
	}
	groupedBySource := map[models.SourceInfo][]models.PackageVulns{}

	for i, rawPkg := range packages {
		if len(vulnsResp.Results[i].Vulns) == 0 && !allPackages && !licenses {
			continue
		}

		pkg := models.PackageVulns{
			Vulnerabilities: []models.Vulnerability{},
			Groups:          []models.GroupInfo{},
		}
		if rawPkg.Commit != "" {
			pkg.Package.Version = rawPkg.Commit
			pkg.Package.Ecosystem = "GIT"
		} else if rawPkg.PURL != "" {
			var err error
			pkg.Package, err = models.PURLToPackage(rawPkg.PURL)
			if err != nil {
				r.PrintError(fmt.Sprintf("Failed to parse purl: %s, with error: %s",
					rawPkg.PURL, err))

				continue
			}
		} else {
			pkg.Package = models.PackageInfo{
				Name:      rawPkg.Name,
				Version:   rawPkg.Version,
				Ecosystem: string(rawPkg.Ecosystem),
			}
		}

		if len(vulnsResp.Results[i].Vulns) > 0 {
			pkg.Vulnerabilities = vulnsResp.Results[i].Vulns
			groups := grouper.Group(grouper.ConvertVulnerabilityToIDAliases(pkg.Vulnerabilities))
			pkg.Groups = groups
		}
		if licenses {
			pkg.Licenses = licensesResp[i]
			if len(licensesAllowlist) > 0 && !(len(licensesAllowlist) == 1 && licensesAllowlist[0] == "") {
				pkg.LicenseViolations = []models.License{}
				allowlist := make(map[string]bool)
				for _, license := range licensesAllowlist {
					allowlist[string(license)] = true
				}
				for _, license := range pkg.Licenses {
					if !allowlist[string(license)] {
						pkg.LicenseViolations = append(pkg.LicenseViolations, license)
					}
				}
			}
		}
		groupedBySource[rawPkg.Source] = append(groupedBySource[rawPkg.Source], pkg)
	}

	for source, packages := range groupedBySource {
		if callAnalysis {
			sourceanalysis.Run(r, source, packages)
		}
		output.Results = append(output.Results, models.PackageSource{
			Source:   source,
			Packages: packages,
		})
	}

	sort.Slice(output.Results, func(i, j int) bool {
		if output.Results[i].Source.Path == output.Results[j].Source.Path {
			return output.Results[i].Source.Type < output.Results[j].Source.Type
		}

		return output.Results[i].Source.Path < output.Results[j].Source.Path
	})

	return output
}
